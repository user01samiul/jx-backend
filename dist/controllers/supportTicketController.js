"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.closeTicket = exports.replyToTicket = exports.createTicket = exports.getTicketById = exports.getUserTickets = void 0;
const postgres_1 = __importDefault(require("../db/postgres"));
/**
 * Support Ticket Controller
 * Handles support ticket creation and management for players
 */
// Get all tickets for the authenticated user
const getUserTickets = async (req, res) => {
    try {
        const userId = req.user.userId;
        const result = await postgres_1.default.query(`SELECT t.id, t.ticket_number, t.subject, t.description, t.category, t.priority, t.status,
              t.created_at, t.updated_at, t.resolved_at, t.closed_at,
              (SELECT message FROM support_ticket_messages WHERE ticket_id = t.id ORDER BY created_at ASC LIMIT 1) as first_message,
              (SELECT COUNT(*) FROM support_ticket_messages WHERE ticket_id = t.id) as message_count
       FROM support_tickets t
       WHERE t.user_id = $1
       ORDER BY t.created_at DESC`, [userId]);
        res.json({
            success: true,
            data: result.rows,
        });
    }
    catch (error) {
        console.error('Error fetching user tickets:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to fetch tickets',
        });
    }
};
exports.getUserTickets = getUserTickets;
// Get single ticket details with all messages
const getTicketById = async (req, res) => {
    try {
        const userId = req.user.userId;
        const { ticketId } = req.params;
        // Get ticket
        const ticketResult = await postgres_1.default.query(`SELECT * FROM support_tickets WHERE id = $1 AND user_id = $2`, [ticketId, userId]);
        if (ticketResult.rowCount === 0) {
            return res.status(404).json({
                success: false,
                message: 'Ticket not found',
            });
        }
        // Get messages
        const messagesResult = await postgres_1.default.query(`SELECT m.id, m.message, m.is_staff, m.created_at, u.username
       FROM support_ticket_messages m
       JOIN users u ON m.user_id = u.id
       WHERE m.ticket_id = $1
       ORDER BY m.created_at ASC`, [ticketId]);
        res.json({
            success: true,
            data: Object.assign(Object.assign({}, ticketResult.rows[0]), { messages: messagesResult.rows }),
        });
    }
    catch (error) {
        console.error('Error fetching ticket:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to fetch ticket details',
        });
    }
};
exports.getTicketById = getTicketById;
// Create new ticket
const createTicket = async (req, res) => {
    try {
        const userId = req.user.userId;
        const { subject, category, priority, message } = req.body;
        if (!subject || !message) {
            return res.status(400).json({
                success: false,
                message: 'Subject and message are required',
            });
        }
        const client = await postgres_1.default.connect();
        try {
            await client.query('BEGIN');
            // Create ticket (ticket_number is auto-generated by trigger)
            const ticketResult = await client.query(`INSERT INTO support_tickets (user_id, subject, description, category, priority, status)
         VALUES ($1, $2, $3, $4, $5, 'new')
         RETURNING *`, [userId, subject, message, category || 'general', priority || 'medium']);
            const ticketId = ticketResult.rows[0].id;
            // Add first message
            await client.query(`INSERT INTO support_ticket_messages (ticket_id, user_id, message, is_staff)
         VALUES ($1, $2, $3, false)`, [ticketId, userId, message]);
            await client.query('COMMIT');
            res.status(201).json({
                success: true,
                message: 'Ticket created successfully',
                data: ticketResult.rows[0],
            });
        }
        catch (error) {
            await client.query('ROLLBACK');
            throw error;
        }
        finally {
            client.release();
        }
    }
    catch (error) {
        console.error('Error creating ticket:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to create ticket',
        });
    }
};
exports.createTicket = createTicket;
// Add reply to ticket
const replyToTicket = async (req, res) => {
    try {
        const userId = req.user.userId;
        const { ticketId } = req.params;
        const { message } = req.body;
        if (!message) {
            return res.status(400).json({
                success: false,
                message: 'Message is required',
            });
        }
        // Verify ticket belongs to user
        const ticketCheck = await postgres_1.default.query(`SELECT id, status FROM support_tickets WHERE id = $1 AND user_id = $2`, [ticketId, userId]);
        if (ticketCheck.rowCount === 0) {
            return res.status(404).json({
                success: false,
                message: 'Ticket not found',
            });
        }
        if (ticketCheck.rows[0].status === 'closed') {
            return res.status(400).json({
                success: false,
                message: 'Cannot reply to closed ticket',
            });
        }
        // Add message
        const result = await postgres_1.default.query(`INSERT INTO support_ticket_messages (ticket_id, user_id, message, is_staff)
       VALUES ($1, $2, $3, false)
       RETURNING *`, [ticketId, userId, message]);
        // Update ticket status to in_progress and track customer reply time
        await postgres_1.default.query(`UPDATE support_tickets
       SET status = 'in_progress',
           last_customer_reply_at = CURRENT_TIMESTAMP,
           updated_at = CURRENT_TIMESTAMP,
           updated_by = $2
       WHERE id = $1`, [ticketId, userId]);
        res.json({
            success: true,
            message: 'Reply added successfully',
            data: result.rows[0],
        });
    }
    catch (error) {
        console.error('Error replying to ticket:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to add reply',
        });
    }
};
exports.replyToTicket = replyToTicket;
// Close ticket
const closeTicket = async (req, res) => {
    try {
        const userId = req.user.userId;
        const { ticketId } = req.params;
        // Verify ticket belongs to user
        const ticketCheck = await postgres_1.default.query(`SELECT id FROM support_tickets WHERE id = $1 AND user_id = $2`, [ticketId, userId]);
        if (ticketCheck.rowCount === 0) {
            return res.status(404).json({
                success: false,
                message: 'Ticket not found',
            });
        }
        // Close ticket
        await postgres_1.default.query(`UPDATE support_tickets
       SET status = 'closed', closed_at = CURRENT_TIMESTAMP, updated_by = $1, updated_at = CURRENT_TIMESTAMP
       WHERE id = $2`, [userId, ticketId]);
        res.json({
            success: true,
            message: 'Ticket closed successfully',
        });
    }
    catch (error) {
        console.error('Error closing ticket:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to close ticket',
        });
    }
};
exports.closeTicket = closeTicket;

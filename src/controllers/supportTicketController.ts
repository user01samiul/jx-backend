import { Request, Response } from 'express';
import pool from '../db/postgres';

/**
 * Support Ticket Controller
 * Handles support ticket creation and management for players
 */

// Get all tickets for the authenticated user
export const getUserTickets = async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user.userId;

    const result = await pool.query(
      `SELECT t.id, t.ticket_number, t.subject, t.description, t.category, t.priority, t.status,
              t.created_at, t.updated_at, t.resolved_at, t.closed_at,
              (SELECT message FROM support_ticket_messages WHERE ticket_id = t.id ORDER BY created_at ASC LIMIT 1) as first_message,
              (SELECT COUNT(*) FROM support_ticket_messages WHERE ticket_id = t.id) as message_count
       FROM support_tickets t
       WHERE t.user_id = $1
       ORDER BY t.created_at DESC`,
      [userId]
    );

    res.json({
      success: true,
      data: result.rows,
    });
  } catch (error) {
    console.error('Error fetching user tickets:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch tickets',
    });
  }
};

// Get single ticket details with all messages
export const getTicketById = async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user.userId;
    const { ticketId } = req.params;

    // Get ticket
    const ticketResult = await pool.query(
      `SELECT * FROM support_tickets WHERE id = $1 AND user_id = $2`,
      [ticketId, userId]
    );

    if (ticketResult.rowCount === 0) {
      return res.status(404).json({
        success: false,
        message: 'Ticket not found',
      });
    }

    // Get messages
    const messagesResult = await pool.query(
      `SELECT m.id, m.message, m.is_staff, m.created_at, u.username
       FROM support_ticket_messages m
       JOIN users u ON m.user_id = u.id
       WHERE m.ticket_id = $1
       ORDER BY m.created_at ASC`,
      [ticketId]
    );

    res.json({
      success: true,
      data: {
        ...ticketResult.rows[0],
        messages: messagesResult.rows,
      },
    });
  } catch (error) {
    console.error('Error fetching ticket:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch ticket details',
    });
  }
};

// Create new ticket
export const createTicket = async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user.userId;
    const { subject, category, priority, message } = req.body;

    if (!subject || !message) {
      return res.status(400).json({
        success: false,
        message: 'Subject and message are required',
      });
    }

    const client = await pool.connect();

    try {
      await client.query('BEGIN');

      // Create ticket (ticket_number is auto-generated by trigger)
      const ticketResult = await client.query(
        `INSERT INTO support_tickets (user_id, subject, description, category, priority, status)
         VALUES ($1, $2, $3, $4, $5, 'new')
         RETURNING *`,
        [userId, subject, message, category || 'general', priority || 'medium']
      );

      const ticketId = ticketResult.rows[0].id;

      // Add first message
      await client.query(
        `INSERT INTO support_ticket_messages (ticket_id, user_id, message, is_staff)
         VALUES ($1, $2, $3, false)`,
        [ticketId, userId, message]
      );

      await client.query('COMMIT');

      res.status(201).json({
        success: true,
        message: 'Ticket created successfully',
        data: ticketResult.rows[0],
      });
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Error creating ticket:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to create ticket',
    });
  }
};

// Add reply to ticket
export const replyToTicket = async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user.userId;
    const { ticketId } = req.params;
    const { message } = req.body;

    if (!message) {
      return res.status(400).json({
        success: false,
        message: 'Message is required',
      });
    }

    // Verify ticket belongs to user
    const ticketCheck = await pool.query(
      `SELECT id, status FROM support_tickets WHERE id = $1 AND user_id = $2`,
      [ticketId, userId]
    );

    if (ticketCheck.rowCount === 0) {
      return res.status(404).json({
        success: false,
        message: 'Ticket not found',
      });
    }

    if (ticketCheck.rows[0].status === 'closed') {
      return res.status(400).json({
        success: false,
        message: 'Cannot reply to closed ticket',
      });
    }

    // Add message
    const result = await pool.query(
      `INSERT INTO support_ticket_messages (ticket_id, user_id, message, is_staff)
       VALUES ($1, $2, $3, false)
       RETURNING *`,
      [ticketId, userId, message]
    );

    // Update ticket status to in_progress and track customer reply time
    await pool.query(
      `UPDATE support_tickets
       SET status = 'in_progress',
           last_customer_reply_at = CURRENT_TIMESTAMP,
           updated_at = CURRENT_TIMESTAMP,
           updated_by = $2
       WHERE id = $1`,
      [ticketId, userId]
    );

    res.json({
      success: true,
      message: 'Reply added successfully',
      data: result.rows[0],
    });
  } catch (error) {
    console.error('Error replying to ticket:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to add reply',
    });
  }
};

// Close ticket
export const closeTicket = async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user.userId;
    const { ticketId } = req.params;

    // Verify ticket belongs to user
    const ticketCheck = await pool.query(
      `SELECT id FROM support_tickets WHERE id = $1 AND user_id = $2`,
      [ticketId, userId]
    );

    if (ticketCheck.rowCount === 0) {
      return res.status(404).json({
        success: false,
        message: 'Ticket not found',
      });
    }

    // Close ticket
    await pool.query(
      `UPDATE support_tickets
       SET status = 'closed', closed_at = CURRENT_TIMESTAMP, updated_by = $1, updated_at = CURRENT_TIMESTAMP
       WHERE id = $2`,
      [userId, ticketId]
    );

    res.json({
      success: true,
      message: 'Ticket closed successfully',
    });
  } catch (error) {
    console.error('Error closing ticket:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to close ticket',
    });
  }
};
